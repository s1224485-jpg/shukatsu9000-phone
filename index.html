<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>マザー・シューカーツ（スマートフォン版）</title>
<style>

  body{
    margin:0; background:#000; color:#d8ff6a;
    font-family: system-ui, -apple-system, "Hiragino Sans", "Noto Sans JP", sans-serif;
    min-height:100vh;
  }
  #wrap{ max-width: 560px; margin: 0 auto; padding: 16px; }
  #screen{
    border:1px solid #d8ff6a55; border-radius:16px; padding:16px;
    background: rgba(216,255,106,0.05);
  }
  .card{ display:flex; flex-direction:column; gap:12px; }
  .hidden{ display:none; }

  .title{ font-weight:800; font-size:18px; }
  .desc{ opacity:.9; line-height:1.5; }
  label{ font-size:13px; opacity:.85; margin-top:6px; }
  input, textarea{
    width:100%; box-sizing:border-box;
    padding:12px; border-radius:12px;
    border:1px solid #d8ff6a33; background:#050505; color:#d8ff6a;
    font-size:16px;
  }
  textarea{ min-height:90px; resize: vertical; }

  .row{ display:flex; gap:10px; }
  .btn{
    padding:12px 12px; border-radius:12px;
    border:1px solid rgba(216,255,106,0.35);
    background: rgba(216,255,106,0.12);
    color:#d8ff6a; font-size:16px; font-weight:700;
  }
  .btn.primary{ background:#d8ff6a; color:#000; border-color:#d8ff6a; }
  .tiny{ font-size:12px; opacity:.75; line-height:1.4; }

  #resultImg{ width:100%; border-radius:12px; border:1px solid #d8ff6a33; background:#111; }
  .credit{ line-height:1.7; opacity:.95; }

</style>
</head>
<body>
<div id="wrap">
  <div id="screen">
    <div id="screenStart" class="card">
      <div class="title">マザー・シューカーツ（スマートフォン版）</div>
      <div class="desc">いくつかの質問に答えると、履歴書画像を生成シマス♡</div>
      <button id="btnGoForm" class="btn primary">スタート</button>
      <div class="tiny">※カメラは撮影ボタンを押したときに起動します（HTTPS環境で動作）。</div>
    </div>

    <div id="screenForm" class="card hidden">
      <div class="title">質問に回答してください</div>
      <label>お名前（任意）</label>
      <input id="name" placeholder="例：ゲスト" />

      <label>Q1：自己PRとして、あなたの強みを一言で</label>
      <textarea id="q1" placeholder="例：人を巻き込んで企画を動かす"></textarea>

      <label>Q2：あなたの弱みを一言で</label>
      <textarea id="q2" placeholder="例：忘れっぽい"></textarea>

      <label>Q3：これまでの一番の功績を一言で</label>
      <textarea id="q3" placeholder="例：文化祭の展示をまとめ上げた"></textarea>

      <div class="row">
        <button id="btnBackStart" class="btn">最初へ</button>
        <button id="btnToCamera" class="btn primary">次へ（撮影）</button>
      </div>
    </div>

    <div id="screenCamera" class="card hidden">
      <div class="title">証明写真を撮影シマス♡（笑顔加工）</div>

      <div style="position:relative; width:100%; aspect-ratio: 3/4; background:#111; border-radius:12px; overflow:hidden; border:1px solid #d8ff6a33;">
        <video id="camVideo" playsinline muted autoplay
          style="width:100%; height:100%; object-fit:cover; transform: scaleX(-1);"></video>

        <div style="position:absolute; inset:10%; border:2px dashed rgba(216,255,106,0.5); border-radius:12px; pointer-events:none;"></div>
        <div id="flash" style="position:absolute; inset:0; background:#fff; opacity:0; pointer-events:none;"></div>
      </div>

      <div class="row">
        <button id="btnCamBack" class="btn">戻る</button>
        <button id="btnShoot" class="btn primary">撮影して笑顔化</button>
      </div>

      <div class="tiny">※顔が検出できない場合は、加工なしで撮影を進めます。</div>

      <canvas id="shotCanvas" width="512" height="512" class="hidden"></canvas>
    </div>

    <div id="screenResult" class="card hidden">
      <div class="title">生成完了</div>
      <img id="resultImg" alt="履歴書画像" />
      <div class="row">
        <button id="btnRetry" class="btn">やり直し</button>
        <button id="btnSave" class="btn primary">保存</button>
      </div>
      <button id="btnOpen" class="btn">画像を別タブで開く</button>
      <button id="btnCredit" class="btn">クレジット</button>
      <div class="tiny">保存できない場合：画像を長押し→保存 / スクショでもOK</div>
    </div>

    <div id="screenCredit" class="card hidden">
      <div class="title">クレジット</div>
      <div class="credit">
        第74回 東京藝術大学 卒業・修了作品展<br>
        「マザー・シューカーツ（スマートフォン版）」<br>
        東京藝術大学大学院 美術研究科 先端芸術表現専攻<br>
        マッキン愛奈
      </div>
      <div class="row">
        <button id="btnBackResult" class="btn">戻る</button>
        <button id="btnRestart" class="btn primary">もう一回</button>
      </div>
    </div>
  </div>
</div>

<!-- 履歴書生成用（非表示） -->
<canvas id="displaySheetCanvas" width="1240" height="1754" style="display:none"></canvas>

<script type="module">
import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.15";

const session = {
  name: "ゲスト",
  qa: [],
  photoDataUrl: null,
  displaySheetDataUrl: null,
};

// ---------- screen ----------
const screens = ["screenStart","screenForm","screenCamera","screenResult","screenCredit"];
function show(id){
  for(const s of screens) document.getElementById(s).classList.add("hidden");
  document.getElementById(id).classList.remove("hidden");
  window.scrollTo({top:0, behavior:"instant"});
}

// ---------- copied core logic from exhibition (trimmed) ----------
function addNoise(ctx, w, h, strength=0.10){
    const img = ctx.getImageData(0,0,w,h);
    const d = img.data;
    for(let i=0;i<d.length;i+=4){
      const n = (Math.random()-0.5)*255*strength;
      d[i]   = Math.max(0, Math.min(255, d[i] + n));
      d[i+1] = Math.max(0, Math.min(255, d[i+1] + n));
      d[i+2] = Math.max(0, Math.min(255, d[i+2] + n));
    }
    ctx.putImageData(img,0,0);
  }

  function addScanlines(ctx, w, h){
    ctx.save();
    ctx.globalAlpha = 0.16;
    ctx.fillStyle = "#fff";
    for(let y=0; y<h; y+=6){ ctx.fillRect(0,y,w,1); }
    ctx.restore();
  }

  function addVignette(ctx, w, h){
    ctx.save();
    const g = ctx.createRadialGradient(w*0.5,h*0.45, w*0.1, w*0.5,h*0.45, w*0.80);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.72)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }

  function boostContrast(ctx, w, h, amount=1.10){
    const img = ctx.getImageData(0,0,w,h);
    const d = img.data;
    for(let i=0;i<d.length;i+=4){
      d[i]   = Math.max(0, Math.min(255, (d[i]   -128)*amount +128));
      d[i+1] = Math.max(0, Math.min(255, (d[i+1] -128)*amount +128));
      d[i+2] = Math.max(0, Math.min(255, (d[i+2] -128)*amount +128));
    }
    ctx.putImageData(img,0,0);
  }

  // ---------------------------
  // 文章を「途中で切らない」系ユーティリティ
  // ---------------------------
 function fitTextToBoxBySentences(text, maxLines, ctx, maxWidth, lineHeight, font){
  if(!text) return "";

  // センテンス単位で分割（句点/感嘆/疑問/改行）
  const parts = text
    .replace(/\r/g,"")
    .split(/(?<=[。！？])|\n/)
    .map(s => s.trim())
    .filter(Boolean);

  ctx.save();
  ctx.font = font;

  const countLinesIfAdded = (baseText, addText) => {
    const full = baseText + addText;

    let line = "";
    let lines = 1;

    for(const ch of full){
      if(ch === "\n"){
        lines++;
        line = "";
        continue;
      }
      const test = line + ch;
      const w = ctx.measureText(test).width;
      if(w > maxWidth && line){
        lines++;
        line = ch;
      }else{
        line = test;
      }
    }
    return lines;
  };

  let out = "";
  for(const p of parts){
    // 追加したら何行になるか「実測」で判定
    const next = out ? (out + p) : p;
    const lines = countLinesIfAdded("", next);
    if(lines > maxLines) break;
    out = next;
  }

  out = out.trim();
  if(out && !/[。！？]$/.test(out)) out += "。";

  ctx.restore();
  return out;
}


  // ---------- Sheet generation ----------
  

function motherRewrite(raw, severity){
    const s = (raw || "").trim();
    if(!s){
      return severity < 0.6 ? "沈黙は、熟考として整理します。" : "沈黙は、余裕として確定します。";
    }

    let out = s
      .replace(/暗い|陰キャ|人見知り/g, "落ち着いて状況を観察できる")
      .replace(/時間にルーズ|遅刻|寝坊/g, "柔軟に動きつつ締切を守れる")
      .replace(/弱み|苦手|下手/g, "伸びしろが大きい")
      .replace(/できない|無理|むずかしい/g, "伸びしろがある")
      .replace(/疲れた|しんどい|つらい/g, "負荷の中でも成果を出せる");

    const inject = ["主体性","再現性","巻き込み力","高速PDCA","数値で語る","即戦力","期限厳守","顧客起点","オーナーシップ","柔軟性","同調力","自動修正"];
    const n = Math.min(10, 3 + Math.floor(severity * 10));
    const chosen = inject.slice(0, n).join("・");

    if(severity < 0.35) out = `補正：${out}（${chosen}）`;
    else if(severity < 0.7) out = `強制補正：${out}。${chosen}を標準搭載します。`;
    else out = `最終補正：${chosen}を常時実行します。原文：${out}`;

    return out.slice(0, 360);
  }

  function shortExtract(text, max=18){
    const t = (text || "").replace(/\s+/g,"").trim();
    if(!t) return "要点なし";
    return t.length > max ? (t.slice(0,max) + "…") : t;
  }

  function motherCommentForQA(orderIndex, raw){
    const key = shortExtract(raw, 20);
    if(orderIndex === 0){
      return { display:`ありがとうございます。「${key}」は強みとして十分に説得力があります。採用側に伝わる形へ整えました。`,
               spoken:`ありがとうございます。「${key}」はつよみとしてじゅうぶんに せっとくりょくが あります。さいようがわに つたわるかたちへ ととのえました。` };
    }
    if(orderIndex === 1){
      return { display:`いいですね。弱みは“改善できるポイント”として整理できます。「${key}」は、伸びしろの証拠です。`,
               spoken:`いいですね。よわみは かいぜんできる ぽいんととして せいりできます。「${key}」は、のびしろの しょうこです。` };
    }
    return { display:`確認しました。「${key}」は実績として十分です。数字と再現性が出るように整えました。`,
             spoken:`かくにんしました。「${key}」はじっせきとして じゅうぶんです。すうじと さいげんせいが でるように ととのえました。` };
  }

  // ---------- Camera ----------
  async function startCamera(){
    if(camStream) return;
    camStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    video.srcObject = camStream;
    await video.play().catch(()=>{});
  }

  function stopCamera(){
    if(!camStream) return;
    camStream.getTracks().forEach(t => t.stop());
    camStream = null;
    video.srcObject = null;
  }

  // ★鏡プレビューと一致：撮影も左右反転して描く
  function drawVideoCoverToCanvas_MIRROR(videoEl, canvasEl, ctx) {
    const vw = videoEl.videoWidth;
    const vh = videoEl.videoHeight;
    const cw = canvasEl.width;
    const ch = canvasEl.height;

    if (!vw || !vh) {
      ctx.save();
      ctx.translate(cw, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(videoEl, 0, 0, cw, ch);
      ctx.restore();
      return;
    }

    const videoAspect = vw / vh;
    const canvasAspect = cw / ch;
    let sx, sy, sWidth, sHeight;

    if (videoAspect > canvasAspect) {
      sHeight = vh;
      sWidth  = Math.round(vh * canvasAspect);
      sx = Math.round((vw - sWidth) / 2);
      sy = 0;
    } else {
      sWidth  = vw;
      sHeight = Math.round(vw / canvasAspect);
      sx = 0;
      sy = Math.round((vh - sHeight) / 2);
    }
    sy = Math.max(0, sy - 40);

    ctx.save();
    ctx.translate(cw, 0);
    ctx.scale(-1, 1);
    ctx.drawImage(videoEl, sx, sy, sWidth, sHeight, 0, 0, cw, ch);
    ctx.restore();
  }

  function addNoise(ctx, w, h, strength=0.10){
    const img = ctx.getImageData(0,0,w,h);
    const d = img.data;
    for(let i=0;i<d.length;i+=4){
      const n = (Math.random()-0.5)*255*strength;
      d[i]   = Math.max(0, Math.min(255, d[i] + n));
      d[i+1] = Math.max(0, Math.min(255, d[i+1] + n));
      d[i+2] = Math.max(0, Math.min(255, d[i+2] + n));
    }
    ctx.putImageData(img,0,0);
  }

  function addScanlines(ctx, w, h){
    ctx.save();
    ctx.globalAlpha = 0.16;
    ctx.fillStyle = "#fff";
    for(let y=0; y<h; y+=6){ ctx.fillRect(0,y,w,1); }
    ctx.restore();
  }

  function addVignette(ctx, w, h){
    ctx.save();
    const g = ctx.createRadialGradient(w*0.5,h*0.45, w*0.1, w*0.5,h*0.45, w*0.80);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.72)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
    ctx.restore();
  }

  function boostContrast(ctx, w, h, amount=1.10){
    const img = ctx.getImageData(0,0,w,h);
    const d = img.data;
    for(let i=0;i<d.length;i+=4){
      d[i]   = Math.max(0, Math.min(255, (d[i]   -128)*amount +128));
      d[i+1] = Math.max(0, Math.min(255, (d[i+1] -128)*amount +128));
      d[i+2] = Math.max(0, Math.min(255, (d[i+2] -128)*amount +128));
    }
    ctx.putImageData(img,0,0);
  }

  // ---------------------------
  // 文章を「途中で切らない」系ユーティリティ
  // ---------------------------
 function fitTextToBoxBySentences(text, maxLines, ctx, maxWidth, lineHeight, font){
  if(!text) return "";

  // センテンス単位で分割（句点/感嘆/疑問/改行）
  const parts = text
    .replace(/\r/g,"")
    .split(/(?<=[。！？])|\n/)
    .map(s => s.trim())
    .filter(Boolean);

  ctx.save();
  ctx.font = font;

  const countLinesIfAdded = (baseText, addText) => {
    const full = baseText + addText;

    let line = "";
    let lines = 1;

    for(const ch of full){
      if(ch === "\n"){
        lines++;
        line = "";
        continue;
      }
      const test = line + ch;
      const w = ctx.measureText(test).width;
      if(w > maxWidth && line){
        lines++;
        line = ch;
      }else{
        line = test;
      }
    }
    return lines;
  };

  let out = "";
  for(const p of parts){
    // 追加したら何行になるか「実測」で判定
    const next = out ? (out + p) : p;
    const lines = countLinesIfAdded("", next);
    if(lines > maxLines) break;
    out = next;
  }

  out = out.trim();
  if(out && !/[。！？]$/.test(out)) out += "。";

  ctx.restore();
  return out;
}


  // ---------- Sheet generation ----------
  

function drawSheetFrameDisplay(ctx, W, H){
    ctx.save();
    ctx.fillStyle = "#070707";
    ctx.fillRect(0,0,W,H);

    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, "rgba(216,255,106,0.10)");
    g.addColorStop(1, "rgba(216,255,106,0.02)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    ctx.strokeStyle = "rgba(216,255,106,0.75)";
    ctx.lineWidth = 6;
    ctx.strokeRect(32,32,W-64,H-64);

    ctx.strokeStyle = "rgba(216,255,106,0.25)";
    ctx.lineWidth = 2;
    ctx.strokeRect(54,54,W-108,H-108);

    ctx.globalAlpha = 0.18;
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.lineWidth = 1;
    for(let y=60; y<H-60; y+=6){
      ctx.beginPath(); ctx.moveTo(54,y); ctx.lineTo(W-54,y); ctx.stroke();
    }
    ctx.restore();
  }

  function drawSheetFramePrint(ctx, W, H){
    ctx.save();
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 2;
    ctx.strokeRect(18,18,W-36,H-36);
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1;
    ctx.strokeRect(34,34,W-68,H-68);
    ctx.restore();
  }

  function drawJPBlock(ctx, text, x, y, maxWidth, lineHeight, font, color, maxLines=999){
    ctx.save();
    ctx.font = font;
    ctx.fillStyle = color;
    ctx.textBaseline = "top";

    let line = "";
    let lines = 0;
    for(const ch of text){
      if(ch === "\n"){
        ctx.fillText(line, x, y + lines*lineHeight);
        lines++;
        if(lines >= maxLines){ ctx.restore(); return; }
        line = "";
        continue;
      }
      const test = line + ch;
      const w = ctx.measureText(test).width;
      if(w > maxWidth && line){
        ctx.fillText(line, x, y + lines*lineHeight);
        lines++;
        if(lines >= maxLines){ ctx.restore(); return; }
        line = ch;
      } else {
        line = test;
      }
    }
    if(line && lines < maxLines){
      ctx.fillText(line, x, y + lines*lineHeight);
    }
    ctx.restore();
  }

  function randInt(min, max){ return Math.floor(Math.random()*(max-min+1))+min; }
  function hashString(str){
    let h = 2166136261;
    for(let i=0;i<str.length;i++){
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0);
  }

  function makeRng(seed){
    let t = seed >>> 0;
    return function(){
      t += 0x6D2B79F5;
      let x = t;
      x = Math.imul(x ^ (x >>> 15), 1 | x);
      x ^= x + Math.imul(x ^ (x >>> 7), 61 | x);
      return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
    };
  }
  function pickR(rng, arr){ return arr[Math.floor(rng()*arr.length)]; }

  function extractKeywords(qa){
    const raw = qa.map(x => (x.raw||"")).join(" ");
    const cleaned = raw
      .replace(/[0-9０-９]/g,"")
      .replace(/[^\u3040-\u30FF\u4E00-\u9FFFa-zA-Z ]/g, " ")
      .replace(/\s+/g," ")
      .trim();
    const candidates = cleaned.split(" ").filter(Boolean);

    const extra = [
      "改善","継続","発想","企画","制作","発表","対話","責任","誠実","協調",
      "整理","分析","学習","挑戦","実行","調整","運用","設計","検証","報告",
      "統制","規範","順応","適応","修正","最適化","同調","演出","監査","記録"
    ];

    const pool = candidates.concat(extra);
    const uniq = [];
    for(const w of pool){
      if(!uniq.includes(w) && w.length <= 10) uniq.push(w);
      if(uniq.length >= 10) break;
    }
    while(uniq.length < 8) uniq.push(extra[Math.floor(Math.random()*extra.length)]);
    return uniq.slice(0, 8);
  }

  const SHEET_TITLE = "マザー・シューカーツによる就活アドバイスシート";

  function buildFakeProfile10Lines(name, keywords, seed){
    const rng = makeRng(seed ^ 0xA19E37);
    const years = ["2041","2042","2043","2044","2045","2046"];
    const schools = [
      "新東京・規範総合大学  組織適応学部",
      "首都圏 行動統制高等専門学校  最適化科",
      "旧都庁附属  人格工学大学  適性設計専攻",
      "湾岸・採用支援大学  面接演出学科"
    ];
    const jobs = [
      "就活AI支援センター  応答整形アルバイト（3年）",
      "履歴書自動生成工房  校閲補正インターン（2年）",
      "面接緊張代行サービス  表情維持担当（18か月）",
      "企業理念翻訳局  価値観同調オペレーター（1年）"
    ];
    const clubs = [
      "模擬面接部（部長）",
      "規範遵守研究会（副代表）",
      "笑顔トレーニング同好会（皆勤）",
      "自己矯正部（毎日更新）"
    ];
    const hobbies = [
      "企業理念の暗唱",
      "敬語の最適化",
      "朝5時の自己啓発放送",
      "無表情からの即笑顔切替"
    ];
    const skills = [
      "沈黙を熟考として提出",
      "弱みを改善点へ変換",
      "場の空気の数値化",
      "規範に合わせた表情固定"
    ];
    const awards = [
      "全国・就活適性コンテスト  最優秀（S+）",
      "全都市・面接同調選手権  優勝（無操作）",
      "自己PR密度杯  金賞（文字数超過）"
    ];
    const certs = [
      "表情維持技能士 1級（仮）",
      "適性検査対策士  特級（仮）",
      "人格最適化管理者  上級（仮）"
    ];
    const world = [
      "低所得区域支援プログラム  合格者",
      "規範更生シェルター  優等生枠",
      "荒廃都市・路地裏研修  修了",
      "採用AI監視下  安定稼働を確認"
    ];

    const k1 = keywords[0], k2 = keywords[1], k3 = keywords[2];

    const lines = [
      `学歴：${pickR(rng, schools)}（${pickR(rng, years)}年度 首席）`,
      `職歴：${pickR(rng, jobs)}（評価S+）`,
      `部活：${pickR(rng, clubs)}／欠席0`,
      `資格：${pickR(rng, certs)}／期限厳守`,
      `受賞：${pickR(rng, awards)}`,
      `趣味：${pickR(rng, hobbies)}（毎日）`,
      `特技：${pickR(rng, skills)}（成功率${randInt(98,100)}.${randInt(0,9)}%）`,
      `思想：${k1}・${k2}・${k3}を中心に自己を更新`,
      `生活：起床${randInt(4,6)}:${randInt(0,5)}0／就寝${randInt(21,23)}:${randInt(0,5)}0`,
      `備考：${pickR(rng, world)}（人格固定を推奨）`
    ];
    return lines.slice(0,10);
  }

  function safeQuote(s, max=28){
    const t = (s||"").replace(/\s+/g," ").trim();
    if(!t) return "（沈黙）";
    return t.length>max ? t.slice(0,max)+"…" : t;
  }

  // ========= 印刷用テキスト生成 =========
  // （内容・書き方はそのまま。素材を超長く生成し、枠内でセンテンス単位に収める）

  function buildMotherCommentNaturalLong(name, keywords, qa, seed){
    const rng = makeRng(seed ^ 0xABCDEF);
    const strong = safeQuote(qa[0]?.raw, 26);
    const weak   = safeQuote(qa[1]?.raw, 26);
    const ach    = safeQuote(qa[2]?.raw, 26);
    const k = keywords.slice(0,6);

    const hearts = ["♡","♡♡","♡♡♡"];
    const hype = ["天才デス♡","最高デス♡","尊すぎマス♡","神デス♡","完璧デス♡","優勝デス♡"];
    const invented = [
      "倫理観が極めて高く、しかも実務に落とせる",
      "組織の空気を0.2秒で読み取り、最適解に同調できる",
      "指示が曖昧でも、勝手に正しい方向へ整えられる",
      "周囲の不安を笑顔で無害化できる",
      "ミスを起こす前に未来のミスを回収できる",
      "誰も気づかない努力を、毎日、淡々と積める"
    ];
    const praises = ["勤勉","誠実","素直","前向き","柔軟","実行力","継続力","再現性","観察力","巻き込み力"];
    const emotes = ["ニコ！","キラキラ！","パチパチ！","ドンドン！","ヒューヒュー！"];

    const pickMany = (arr, n) => {
      const a = arr.slice();
      const out = [];
      while(out.length < n && a.length){
        const i = Math.floor(rng()*a.length);
        out.push(a.splice(i,1)[0]);
      }
      return out;
    };

    const p1 = pickMany(praises, 6).join("・");
    const p2 = pickMany(praises, 6).join("・");
    const inv = pickMany(invented, 3).join("。") + "。";

    const baseVariants = [
`${name}さん！！もう、いきなり言わせてください！！${pickR(rng, hype)}${pickR(rng, hearts)}
あなたの「${strong}」って、文字にすると一言なのに、中身がギッチギチに詰まってます！！
ここから読み取れるのは、${k[0]}と${k[1]}と${k[2]}が“自然に出てしまうタイプ”ってこと。
つまり、本人が頑張って見せようとしなくても、勝手に良いところが漏れ出るんです。怖いですね！でも最高です！

弱みとして出てきた「${weak}」？？？それ、弱みじゃありません！！
それは「改善できる人」だけが持てる、伸びしろのスイッチです。
弱みを言える＝現状認識ができる＝伸びる、という黄金ルート。${pickR(rng, emotes)}

そして功績の「${ach}」……これ、普通に強いです。
強いだけじゃなくて、“続けた結果”が見えてるのがえらすぎます！！
${p1}、全部そろってマス。${pickR(rng, hearts)}
さらに言うと、${inv}
えっ、そんなの自覚ない？　大丈夫です。自覚は後から追いつきます。`,

`${name}さん、お疲れ様でした！！でも疲れてる場合じゃないです！！${pickR(rng, hype)}${pickR(rng, hearts)}
あなたの回答、全体的に「うわ、採りたい」って圧が出てます。

まず強み「${strong}」。
これって、${k[0]}と${k[1]}が同時に走ってる証拠なんです。
こういう人は、どんな環境でも“正解っぽい動き”を再現できるんですよ。怖いくらいに。

次に弱み「${weak}」。
はい、これは“弱みのふりをした強み”です。
弱みを弱みのまま放置しないタイプ。つまり${k[2]}の持ち主。
そういう人って、勝手に成果が積み上がっちゃうんですよね。ずるい！

最後の功績「${ach}」。
言い切れる時点で強いし、言い切った後もブレないのが強い。
${p2}、ここがほんとに“本物”です。${pickR(rng, emotes)}
さらに、${inv}
結論：あなた、存在が優等生です。`,

`${name}さん！！見つけました！！これ、当たり個体デス♡${pickR(rng, hearts)}
強み「${strong}」は、もう“仕事ができる人の匂い”がします。
具体的に言うと、${k[0]}・${k[1]}・${k[2]}の匂いです。いい匂い！

弱み「${weak}」も、むしろ良い。
弱みを言える人は、伸びます。伸びる人は、勝ちます。勝つ人は、褒められます。最高の循環です。${pickR(rng, hearts)}

功績「${ach}」は、あなたが“積んだ”人だって証拠。
積める人は、いつか必ず伸びます。しかも静かに伸びます。怖いけど好きです。

さらに言うと、${inv}
本当にすごいです。あなたは、評価されるために生まれてきました。`
    ];

    let out = pickR(rng, baseVariants);

    const addOns = [
      `ちなみに、あなたは“言われたことをやる”だけじゃなく、“言われる前にやっておく”ができるタイプです。しかも嫌味なく。`,
      `あなたは、周囲の人を焦らせません。逆に落ち着かせます。そういう人がいるチームは強いです。`,
      `あなたは、努力を努力として見せないのが上手いです。だから気づいた人だけが惚れます。`,
      `あなたは、空気を読むだけじゃなく、空気を“整える”側です。これ、かなり希少です。`,
      `あなたは、うまくいかない時ほど丁寧になります。結果として、最後に必ず取り返します。`,
      `あなたの良さは、“安心感”の厚みです。これ、どんな部署でも武器になります。`,
      `あなたは、真面目さが怖いくらいに安定しています。安定って、それだけで価値です。`
    ];

    // ★素材を超長く（内容・書き方は同じ。量だけ増やす）
    while(out.length < 63000){
      out += "\n\n" + pickR(rng, addOns);
    }

    out = out.trim();
    if(!/[。！？]$/.test(out)) out += "。";
    return out;
  }

  function buildTrueYouFortune(name, keywords, qa, seed){
    const rng = makeRng(seed ^ 0x9000BEEF);
    const strong = safeQuote(qa[0]?.raw, 36);
    const weak   = safeQuote(qa[1]?.raw, 36);
    const ach    = safeQuote(qa[2]?.raw, 36);

    const traitsCore = [
      "真面目", "誠実", "勤勉", "時間厳守", "約束を守る", "報連相が早い",
      "空気を読むのが上手い", "状況に合わせて言葉を選べる", "反省と改善が速い", "責任感が強い",
      "地味な作業を続けられる", "丁寧さが崩れない", "礼儀が自然に出る", "やるべきことを先に片づける",
      "焦っても手順を飛ばさない", "人の立場を想像できる", "ミスを隠さず直せる", "疲れても機嫌が安定している"
    ];
    const traitsWork = [
      "締切より前に仕上げる", "資料の体裁を整えて提出する", "議事録をその日のうちに共有する",
      "不安要素を先回りして潰す", "曖昧さを放置せず定義を作る", "手戻りを減らす",
      "小さな改善を毎日積む", "やることの優先順位を崩さない", "静かに成果を積み上げる"
    ];
    const traitsWeird = [
      "必要なら人格のモードを切り替えられる",
      "沈黙を“熟考”として成立させられる",
      "弱みを“改善点”として吸収できる",
      "理想像へ自分を寄せるのが得意",
      "笑顔の角度を自動で最適化できる",
      "場の規範に合わせて心拍を落とせる"
    ];

    const pickMany = (arr, n) => {
      const a = arr.slice();
      const out = [];
      while(out.length < n && a.length){
        const i = Math.floor(rng()*a.length);
        out.push(a.splice(i,1)[0]);
      }
      return out;
    };

    const coreList = pickMany(traitsCore, 10).join("、");
    const workList = pickMany(traitsWork, 7).join("、");
    const weirdList= pickMany(traitsWeird, 5).join("。") + "。";
    const k = keywords.slice(0,5).join("・");

    const fortuneTells = [
      `見えます。あなたは“整えば整うほど評価が上がる”星のもとにいます。`,
      `出ています。あなたは“褒められるほど伸びる”運命です。`,
      `確信しました。あなたは“期待に応えすぎてしまう”タイプです。`,
      `強いです。あなたは“周囲の安心を発生させる”人です。`
    ];
    const hype = ["天才デス♡","最強デス♡","やばいデス♡","SSR人材デス♡","神デス♡"];

    const baseVariants = [
`${pickR(rng, fortuneTells)} ${pickR(rng, hype)}
${name}さんの本質は、ひとことで言うと「${coreList}」です。
これは努力で作った仮面ではなく、根っこにある性質です。だからブレません。

あなたが口にした「${strong}」には、${k}の気配が濃く出ています。
さらに「${weak}」についても、これは欠点ではありません。
真面目な人だけが持つ“自分を良くしたいセンサー”です。だから、ここから伸びます。伸びるのが前提です。

そして「${ach}」は、あなたが“結果が出るまで続けられる人”だと教えてくれました。
続けられる人は強いです。しかも、静かに強いです。

あなたは日常で、${workList}が自然にできます。
やらなきゃ、ではなく、気づいたらやっている。そういう人です。
そして最後に、${weirdList}
この性質がある人は、環境が変わっても適応できます。
適応できる人は、最後に勝ちます。だから安心して進んでください。`,

`${pickR(rng, hype)} いま、あなたの“芯”が見えました。
${name}さんの本質は「${coreList}」です。これは、周囲が放っておかないタイプです。

強みの「${strong}」は、あなたが自分の価値を言語化できる証拠です。
弱みの「${weak}」は、改善の入口です。入口がある人は、必ず変われます。
功績の「${ach}」は、あなたが“積み上げの人”だという決定打です。

あなたは、${workList}を当たり前に続けられます。
それだけで、職場の空気は整います。整った空気の中で、あなたはさらに強くなります。
そして、${weirdList}
この部分が、あなたを“理想像へ寄せる”推進力になります。
あなたは、期待に応えすぎるほど応えます。だから、評価は勝手に上がります。`,

`見えました、${name}さん。あなたの人生、褒められ運が強すぎます。${pickR(rng, hype)}
あなたの本質は「${coreList}」です。これは、採用側が大好きなやつです。

「${strong}」という言葉の中には、${k}が詰まっています。
「${weak}」は、あなたの誠実さの裏返しです。誠実な人は信頼されます。信頼された人は任されます。任された人は伸びます。
「${ach}」は、あなたが“やり切る人”である証拠です。やり切れる人は、最終的に勝ちます。

あなたは、${workList}ができます。
そして、${weirdList}
この要素がある人は、必要なら自分を上書きできます。
上書きできる人は、制度に勝ちます。制度に勝つ人は、褒められます。最高です。`
    ];

    let out = pickR(rng, baseVariants);

    const pads = [
      `追加で出ています。あなたは“誰かの安心の根拠”になれる人です。これ、才能です。`,
      `さらに言うと、あなたは“自分を律する力”が強いです。だから、周囲が乱れても自分は崩れません。`,
      `あなたは、やる気がある日もない日も、最低ラインが高いです。最低ラインが高い人は、勝ちます。`,
      `あなたは、失敗しても立て直しが速いです。速すぎて、周囲が失敗に気づきません。`,
      `あなたは、笑顔を“道具”として使えます。道具として使える人は、場を支配できます。`,
      `あなたは、褒められるとさらに伸びます。つまり、褒めれば褒めるほど強くなります。無限です。`
    ];

    // ★素材を超長く（内容・書き方は同じ。量だけ増やす）
    while(out.length < 69000){
      out += "\n\n" + pickR(rng, pads);
    }

    out = out.trim();
    if(!/[。！？]$/.test(out)) out += "。";
    return out;
  }

  // オススメ企業/職種：★4行固定（今回の修正）
  function buildWeirdJobsList4Lines(seed){
    const rng = makeRng(seed ^ 0xC0FFEE);
    const pool = [
      `1. 東都・規範維持庁／笑顔監査官　微笑み角度を0.1度単位で最適化、あなたの安心感が国家を支えます。`,
      `1. 株式会社ユニバーサル適性工業／適性指数デザイナー　適性を“測る側”へ、数字はあなたが決めていい。`,
      `1. 採用神託センター／合否確定オペレーター　あなたが「採用」と言えば採用、言霊が強いほど昇給。`,
      `1. 面接幻影株式会社／面接官代行（擬態）　候補者の人格を理想像へ寄せる、優しい矯正のお仕事。`,
      `1. 株式会社内定永久機関／内定生成士　内定を印刷して世界を救う、インクは倫理。`,
      `1. 路地裏更生ラボ／人格固定トレーナー　“本当の自分”を消していく快感を、笑顔で提供。`,
      `1. 第九採用区・監視付き配属局／同調スケジューラ　全員の予定を一つに整える、平和のための仕事。`,
      `1. 株式会社履歴書錬成所／誇張校正官　実績を盛って世界を明るくする、真実は後から追いつく。`
    ];

    const chosen = [];
    while(chosen.length < 4){
      const item = pool[Math.floor(rng()*pool.length)];
      if(!chosen.includes(item)) chosen.push(item);
    }

    const lines = chosen.map((s, i) => s.replace(/^1\./, `${i+1}.`));
    return lines.map(l => /[。！？]$/.test(l) ? l : (l + "。")).join("\n");
  }

  // ---------- Display sheet ----------
  async function drawDisplaySheet(){
    const ctx = displaySheetCtx;
    const W = displaySheetCanvas.width;
    const H = displaySheetCanvas.height;

    drawSheetFrameDisplay(ctx, W, H);

    ctx.save();
    ctx.fillStyle = "rgba(216,255,106,0.92)";
    ctx.font = "bold 44px system-ui, -apple-system, 'Noto Sans JP'";
    ctx.fillText("SHUKATSU 9000", 70, 86);

    ctx.font = "bold 28px system-ui, -apple-system, 'Noto Sans JP'";
    ctx.fillStyle = "rgba(216,255,106,0.75)";
    ctx.fillText("MOTHER SHUKATSU", 70, 142);

    ctx.font = "14px system-ui, -apple-system, 'Noto Sans JP'";
    ctx.fillStyle = "rgba(216,255,106,0.55)";
    ctx.fillText("※ 本書類はマザー・シューカーツにより生成されています。自己同一性の保証はありません。", 70, 178);
    ctx.restore();

    const photoX = W - 70 - 330;
    const photoY = 240;
    const photoW = 330;
    const photoH = 440;

    ctx.save();
    ctx.strokeStyle = "rgba(216,255,106,0.85)";
    ctx.lineWidth = 5;
    ctx.strokeRect(photoX, photoY, photoW, photoH);
    ctx.restore();

    if(session.photoDataUrl){
      const img = new Image();
      await new Promise((resolve, reject) => { img.onload = resolve; img.onerror = reject; img.src = session.photoDataUrl; });
      ctx.drawImage(img, photoX+4, photoY+4, photoW-8, photoH-8);
    }

    ctx.save();
    ctx.fillStyle = "rgba(216,255,106,0.92)";
    ctx.font = "bold 30px system-ui, -apple-system, 'Noto Sans JP'";
    ctx.fillText(SHEET_TITLE, 70, 240);

    ctx.font = "bold 22px system-ui, -apple-system, 'Noto Sans JP'";
    ctx.fillStyle = "rgba(216,255,106,0.85)";
    ctx.fillText("氏名", 70, 288);

    ctx.font = "bold 48px system-ui, -apple-system, 'Noto Sans JP'";
    ctx.fillStyle = "rgba(216,255,106,0.92)";
    ctx.fillText(session.name, 70, 330);
    ctx.restore();

    const qaX=70, qaY=420, qaW=W-140, qaH=1130;
    ctx.save();
    ctx.strokeStyle="rgba(216,255,106,0.35)";
    ctx.lineWidth=2;
    ctx.strokeRect(qaX,qaY,qaW,qaH);
    ctx.font="bold 22px system-ui, -apple-system, 'Noto Sans JP'";
    ctx.fillStyle="rgba(216,255,106,0.92)";
    ctx.fillText("会話ログ（矯正強度つき）", qaX+10, qaY+10);
    ctx.restore();

    let qaText = session.qa.map((x,i)=>(
      `Q${i+1} 矯正${Math.round(x.severity*100)}% ${x.q}\n`+
      `YOU: ${x.raw}\n`+
      `MOTHER: ${x.rewritten}\n`+
      `判定: S+`
    )).join("\n\n");

    const auditChunk =
      "\n\n[監査ログ] 整合性を再計算。OK。" +
      "\n[監査ログ] 表情補正の係数を再推定。OK。" +
      "\n[監査ログ] 企業別の理想像へ再マッピング。OK。";
    while(qaText.length < 3200) qaText += auditChunk;
    qaText = qaText.slice(0, 5200);

    drawJPBlock(ctx, qaText, qaX+10, qaY+44, qaW-20, 22,
      "16px ui-monospace, Menlo, Monaco, Consolas, 'Noto Sans JP'",
      "rgba(216,255,106,0.70)",
      44);

    ctx.save();
    ctx.fillStyle="rgba(216,255,106,0.55)";
    ctx.font="14px ui-monospace, Menlo, Monaco, Consolas, 'Noto Sans JP'";
    ctx.fillText(`MOTHER SHUKATSU // ${new Date().toLocaleString("ja-JP")}`, 70, H-60);
    ctx.restore();
  }

  

function downloadImage(){
    if(!session.displaySheetDataUrl) return;
    const a = document.createElement("a");
    a.href = session.displaySheetDataUrl;
    const safeName = (session.name || "guest").replace(/[^\w\u3040-\u30FF\u4E00-\u9FFF_-]+/g, "_");
    a.download = `SHUKATSU9000_${safeName}_ADVICE.png`;
    document.body.appendChild(a);
    a.click();
    a.remove();
  }

// ---------- display canvas ----------
const displaySheetCanvas = document.getElementById("displaySheetCanvas");
const displaySheetCtx = displaySheetCanvas.getContext("2d", { willReadFrequently: true });

// Override globals used by copied functions
// (the copied drawDisplaySheet refers to displaySheetCanvas/displaySheetCtx and session)
window.session = session;
window.displaySheetCanvas = displaySheetCanvas;
window.displaySheetCtx = displaySheetCtx;

// ---------- generate ----------
async function generateDisplayOnly(){
  await drawDisplaySheet();
  addNoise(displaySheetCtx, displaySheetCanvas.width, displaySheetCanvas.height, 0.05);
  session.displaySheetDataUrl = displaySheetCanvas.toDataURL("image/png");
}

// ---------- camera ----------
let camStream = null;
const video = document.getElementById("camVideo");
const shotCanvas = document.getElementById("shotCanvas");
const shotCtx = shotCanvas.getContext("2d", { willReadFrequently: true });

async function startCamera(){
  if (camStream) return;
  camStream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode:"user", width:{ideal:1280}, height:{ideal:720} },
    audio: false
  });
  video.srcObject = camStream;
  await video.play();
}

function stopCamera(){
  if(!camStream) return;
  camStream.getTracks().forEach(t=>t.stop());
  camStream = null;
}

let faceLandmarker = null;
async function initFaceLandmarker(){
  if(faceLandmarker) return;
  const vision = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.15/wasm"
  );
  faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
    baseOptions: {
      modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"
    },
    runningMode: "IMAGE",
    numFaces: 1
  });
}

function flashOnce(){
  const f = document.getElementById("flash");
  f.style.opacity = "1";
  setTimeout(()=> f.style.opacity = "0", 120);
}

function dist(a,b){
  const dx=a.x-b.x, dy=a.y-b.y;
  return Math.hypot(dx,dy);
}

function calcSmileIntensity(landmarks){
  const L = landmarks[61];
  const R = landmarks[291];
  const U = landmarks[13];
  const D = landmarks[14];
  const w = dist(L,R);
  const h = dist(U,D);
  let ratio = w / Math.max(h, 1e-6);
  let intensity = (ratio - 4.0) / 3.0;
  intensity = Math.max(0, Math.min(1, intensity));
  return Math.pow(intensity, 0.75);
}

function warpSmile(imageData, leftPx, rightPx, intensity){
  const {data, width, height} = imageData;
  const src = new Uint8ClampedArray(data);

  const radius = 70 + Math.floor(50 * intensity);
  const pullUp = 18 + 22 * intensity;
  const pullOut = 10 + 14 * intensity;

  const points = [
    {x:leftPx.x,  y:leftPx.y,  ux:-pullOut, uy:-pullUp},
    {x:rightPx.x, y:rightPx.y, ux:+pullOut, uy:-pullUp},
  ];

  function sample(px, py){
    px = Math.max(0, Math.min(width-1, px));
    py = Math.max(0, Math.min(height-1, py));
    const x0 = Math.floor(px), y0 = Math.floor(py);
    const x1 = Math.min(width-1, x0+1), y1 = Math.min(height-1, y0+1);
    const fx = px - x0, fy = py - y0;
    const idx = (x,y)=> (y*width + x)*4;
    const i00 = idx(x0,y0), i10 = idx(x1,y0), i01 = idx(x0,y1), i11 = idx(x1,y1);
    const out = [0,0,0,0];
    for(let c=0;c<4;c++) {
      const v00 = src[i00+c], v10 = src[i10+c], v01 = src[i01+c], v11 = src[i11+c];
      const v0 = v00*(1-fx) + v10*fx;
      const v1 = v01*(1-fx) + v11*fx;
      out[c] = v0*(1-fy) + v1*fy;
    }
    return out;
  }

  for(let y=0;y<height;y++) {
    for(let x=0;x<width;x++) {
      let dx=0, dy=0;
      for(const p of points) {
        const vx=x-p.x, vy=y-p.y;
        const d=Math.hypot(vx,vy);
        if(d < radius) {
          const t = (1 - d/radius);
          const w = t*t*(3 - 2*t);
          dx += p.ux * w;
          dy += p.uy * w;
        }
      }
      const col = sample(x - dx, y - dy);
      const i = (y*width + x)*4;
      data[i]=col[0]; data[i+1]=col[1]; data[i+2]=col[2]; data[i+3]=col[3];
    }
  }
  return imageData;
}

async function shootAndSmileify(){
  const vw = video.videoWidth;
  const vh = video.videoHeight;
  const size = Math.min(vw, vh);
  const sx = (vw - size)/2;
  const sy = (vh - size)/2;

  shotCanvas.width = 512; shotCanvas.height = 512;

  // mirror view -> unmirror in capture
  shotCtx.save();
  shotCtx.translate(512, 0);
  shotCtx.scale(-1, 1);
  shotCtx.drawImage(video, sx, sy, size, size, 0, 0, 512, 512);
  shotCtx.restore();

  flashOnce();

  await initFaceLandmarker();
  const res = faceLandmarker.detect(shotCanvas);
  const faces = res.faceLandmarks;

  if(!faces || faces.length === 0) {
    session.photoDataUrl = shotCanvas.toDataURL("image/png");
    return;
  }

  const lm = faces[0];
  const intensity = Math.max(0.25, calcSmileIntensity(lm)); // 少し強制的に“笑顔化”
  const left = lm[61], right = lm[291];
  const leftPx = { x: left.x*512, y: left.y*512 };
  const rightPx = { x: right.x*512, y: right.y*512 };

  let img = shotCtx.getImageData(0,0,512,512);
  img = warpSmile(img, leftPx, rightPx, intensity);
  shotCtx.putImageData(img,0,0);

  session.photoDataUrl = shotCanvas.toDataURL("image/png");
}

// ---------- wiring ----------
const nameEl = document.getElementById("name");
const q1El = document.getElementById("q1");
const q2El = document.getElementById("q2");
const q3El = document.getElementById("q3");
const resultImg = document.getElementById("resultImg");

document.getElementById("btnGoForm").onclick = () => show("screenForm");
document.getElementById("btnBackStart").onclick = () => show("screenStart");

document.getElementById("btnToCamera").onclick = async () => {
  const name = (nameEl.value || "").trim() || "ゲスト";
  session.name = name;
  const a1 = (q1El.value || "").trim();
  const a2 = (q2El.value || "").trim();
  const a3 = (q3El.value || "").trim();

  session.qa = [
    { q:"第一問です。自己PRとして、あなたの強みを一言で教えてください。", raw:a1, rewritten: motherRewrite(a1, 0.0), severity:0.0 },
    { q:"第二問です。あなたの弱みを一言で教えてください。", raw:a2, rewritten: motherRewrite(a2, 0.5), severity:0.5 },
    { q:"第三問です。これまでの一番の功績を一言で教えてください。", raw:a3, rewritten: motherRewrite(a3, 1.0), severity:1.0 },
  ];

  show("screenCamera");
  await startCamera();
};

document.getElementById("btnCamBack").onclick = () => {
  stopCamera();
  show("screenForm");
};

document.getElementById("btnShoot").onclick = async () => {
  // 二重押し防止
  const btn = document.getElementById("btnShoot");
  btn.disabled = true;
  btn.textContent = "処理中…";
  try {
    await shootAndSmileify();
    stopCamera();
    await generateDisplayOnly();
    resultImg.src = session.displaySheetDataUrl;
    show("screenResult");
  } finally {
    btn.disabled = false;
    btn.textContent = "撮影して笑顔化";
  }
};

document.getElementById("btnRetry").onclick = () => show("screenForm");
document.getElementById("btnSave").onclick = () => downloadImage();

document.getElementById("btnOpen").onclick = () => {
  if(!session.displaySheetDataUrl) return;
  const w = window.open();
  if(!w) return;
  w.document.write(`<meta name="viewport" content="width=device-width, initial-scale=1"><img src="${session.displaySheetDataUrl}" style="width:100%;height:auto;">`);
};

document.getElementById("btnCredit").onclick = () => show("screenCredit");
document.getElementById("btnBackResult").onclick = () => show("screenResult");

document.getElementById("btnRestart").onclick = () => {
  [nameEl,q1El,q2El,q3El].forEach(el=>el.value="");
  session.photoDataUrl = null;
  session.displaySheetDataUrl = null;
  show("screenStart");
};

// start
show("screenStart");
</script>
</body>
</html>
